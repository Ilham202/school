1) The purpose of copyin() and copyout() is to copy data into kernel space from user space and out of kernel space to user space, respectively. These functions are used by the 'uio' device driver I/O routines, which is essentially a user-thread interface for moving data, and necessary in the implementation of I/O system calls (e.g. open, close, read, write). The reason why we need copyin() and copyout() when copying data over the user-kernel space boundary is because they do additional safety checks on addresses supplied by the user-level code before initiating the move, and wrapping the underlying use of standard C memcpy() in a setjmp/longjmp exception handling structure. The initial checks include ensuring that the upper and lower bounds on a range of memory are valid and that the user is not trying to illegally read from or write to kernel memory. The setjump/longjmp logic is structured such that the pcb_badfaultfunc is pointing to a function that calls longjmp, which jumps to the line right before memcpy() and returns EFAULT. By performing these extra checks, we prevent fatal kernel memory faults and add some security to system calls.

2) The difference between UIO_USERISPACE and UIO_USERSPACE is that UIO_USERISPACE (with the extra I) indicates that the user-level memory segment being referenced is executable. UIO_SYSSPACE should be used when the memory segment being referenced (read from or written from) resides within kernel-space (i.e. in the case of using a kuio), and the data transfer resides entirely within kernel-space.

3) In runprogram(), we call vfs_open() on the file containing the user program. Opening a file for the first time allocates a new description in the file descriptor table, and resources associated with it. Opening the same file subsequent times does not allocate additional resources but increases the file's reference and open counters. Calling a symmetric vfs_close() for every vfs_open() is very important because when a file is being closed and the open counter is at 0 (i.e. the last close) the resources and file descriptor associated with it are freed. In cases where the file was deleted while its reference count was greater than 0, the file can now be additionally deleted from secondary memory. It is important to free these resources in runprogram() because after switching to user mode, execution never returns to runprogram(). In a case where we do not call vfs_close() in runprogram(), the resources associated with the file containing the user program would never be freed.

4) The kernel function that is used to make a thread switch to executing user-level code is 'md_usermode()'. This function takes argc, argv, a stack pointer, and an entry point as arguments. These arguments are attached to a 'trapframe' struct, which is passed to assembly code that restores the (expected to be prepared/defined/empty) stack, switches the processor to user mode, and jumps to the entry point. Since non-new threads returning from traps should return from mips_trap() automatically, md_usermode() should only be called by threads entering user mode for the first time (e.g. from fork() or exec()).

5) The purpose of userptr_t is to refer to an address that specifically exists in userspace.

6) The implementation of kill_curthread() should change because it does not clean up/deallocate resources that were being used bythe dying thread. A proper implementation of this function would deallocate the thread's address space, close file descriptors it had open, release and destroy locks it held/used, etc.

7) At the time that both mips_syscall() and kill_curthread() are invoked, interrupts are enabled. Although both are called from the general mips_trap() function (which initially turns off interrupts for extracting exception code info and possible entering an interrupt handeler), interrupts are re-enabled in cases where the trap was not caused by an interrupt.

8) The kernel function that is used to open a file or device and obtain a new vnode is vfs_open().

9) There are many operations that can be done on a vnode. Some include open, close, reclaim (free resources), read, write, truncate, mkdir, rename, and lookup. A complete list can be found in /kern/include/vnode.h. If two different processes open the same file, we do not create a second vnode. Instead, we increment an "open" counter found in the vnode that indicates how many processes have it opened and have the two processes share it. As described above, subsequent calls to close() the vnode decrement the "open" counter, and once this counter reaches zero (no processes wish to keep it open any longer), the vnode is freed.
